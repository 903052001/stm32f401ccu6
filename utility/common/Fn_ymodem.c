/*<FH+>************************************************************************/
/*                                                                            */
/* 版权所有: Copyright (C) Leonard.  2020. All rights reserved.               */
/*                                                                            */
/* 文件名称: Fn_ymodem.c                                                      */
/* 内容摘要: ymodem传输协议的实现源文件                                      */
/* 其它说明: 无                                                               */
/* 当前版本: v 1.0.0                                                          */
/* 作    者: Leonard                                                          */
/* 完成日期: 2020-11-20                                                       */
/* 修改记录:                                                                  */
/*     修改日期          版本号     修改人          修改内容                 */
/* -------------------------------------------------------------------------- */
/*     2020-11-20        v 1.0.0     Leonard         创建文件                 */
/*<FH->************************************************************************/

/******************************************************************************/
/*               #include(依次为标准库头文件、非标准库头文件)                */
/******************************************************************************/
#include  <string.h>
#include "drv_console.h"
#include "Fn_check.h"
#include "Fn_mctype.h"
#include "Fn_format.h"
#include "Fn_ymodem.h"

/******************************************************************************/
/*                                外部引用声明                                */
/******************************************************************************/


/******************************************************************************/
/*                                 内部宏定义                                 */
/******************************************************************************/
#define YMODEM_OK                       (0)     /* 执行成功                   */
#define YMODEM_TIMEOUT                 (-1)     /* 超时                       */
#define YMODEM_EOT                     (-2)     /* 文件传输结束               */
#define YMODEM_CANCEL                  (-3)     /* 文件传输取消               */
#define YMODEM_FRAME                   (-4)     /* 数据块错误                 */
#define YMODEM_CKSUM                   (-5)     /* CRC或校验和错误            */
#define YMODEM_SEQUENCE                (-6)     /* 传输序号错误               */

/******************************************************************************/
/* xyzModem的配置信息                                                         */
/******************************************************************************/
#define YMODEM_CHAR_TMOT_MSEC         (1000)    /* 接收字符的超时时间,单位ms */
#define YMODEM_DELAY                   (10)     /* 单次延时的时间,单位ms     */

#define YMODEM_MAX_ERRORS              (5)      /* 放弃前的连续接收错误数    */
#define YMODEM_MAX_RETRIES             (20)     /* 最大重试次数              */
#define YMODEM_MAX_RETRIES_WITH_CRC    (10)     /* CRC模式的最大重试次数     */
#define YMODEM_CAN_COUNT               (2)      /* 连续2个CAN信号就终止传输  */

#define FILE_SIZE_LENGTH               (10)     /* 最大的u32是个10位10进制数 */
#define FILE_NAME_LENGTH               (32)     /* 传输文件字符串名长度上限  */
#define PACKET_SIZE_128                (128)    /* 起始/结尾包数据长度       */
#define PACKET_SIZE_1024               (1024)   /* 正文数据包数据长度        */

/******************************************************************************/
/*                              内部数据类型定义                              */
/******************************************************************************/


/******************************************************************************/
/*                                内部函数原型                                */
/******************************************************************************/
static void yModem_msDelay(int ms);
static int  yModem_GetChar(char *ch);
static void yModem_PutChar(char ch);
static void yModem_Flush(void);
static int  yModem_ReceivePacket(T_yModem_STREAM *ptStream);
static void yModem_SendPacket(unsigned char *pData, int xDataSize, int xBlkNo);
static void yModem_SendPacket0(char *sFileName, int ulSize);
static void yModem_SendDataPackets(unsigned char *pData, int ulSize);

/******************************************************************************/
/*                               全局(静态)变量                               */
/******************************************************************************/


/******************************************************************************/
/*                                内部函数实现                                */
/******************************************************************************/
static void yModem_msDelay(int ms)
{
#ifdef  BSP_USE_RT_THREAD
    rt_thread_mdelay(ms);
#else
    HAL_Delay(ms);
#endif
}

/*<FUNC+>**********************************************************************/
/* 函数名称: yModem_GetChar                                                   */
/* 功能描述: 获取一个字符                                                     */
/* 输入参数: ch --- 指向存放获取的字符的缓存区                               */
/* 输出参数: 无                                                               */
/* 返 回 值: 0-超时, 未读取到字符; 1-读取成功                                */
/* 操作流程:                                                                  */
/* 其它说明: 无                                                               */
/* 修改记录:                                                                  */
/* -------------------------------------------------------------------------- */
/*     2020-11-20              v 1.0.0       Leonard       创建函数           */
/*<FUNC->**********************************************************************/
static int yModem_GetChar(char *ch)
{
    int xCnts = 0;
    int xRet  = 0;

    while (!bsp_console_havec() && (xCnts < YMODEM_CHAR_TMOT_MSEC / YMODEM_DELAY))
    {
        yModem_msDelay(YMODEM_DELAY);
        xCnts++;
    }

    if (bsp_console_havec())
    {
        *ch  = bsp_console_getc();
        xRet = 1;
    }

    return xRet;
}

/*<FUNC+>**********************************************************************/
/* 函数名称: yModem_PutChar                                                   */
/* 功能描述: 输出一个字符                                                     */
/* 输入参数: ch --- 输出字符                                                  */
/* 输出参数: 无                                                               */
/* 返 回 值: void                                                             */
/* 操作流程:                                                                  */
/* 其它说明: 无                                                               */
/* 修改记录:                                                                  */
/* -------------------------------------------------------------------------- */
/*     2020-11-20              v 1.0.0       Leonard       创建函数           */
/*<FUNC->**********************************************************************/
static void yModem_PutChar(char ch)
{
    bsp_console_putc(ch);
}

/*<FUNC+>**********************************************************************/
/* 函数名称: yModem_Flush                                                     */
/* 功能描述: 等待传输线进入空闲状态,即一直接收数据并丢弃,直到接收超时       */
/* 输入参数: 无                                                               */
/* 输出参数: 无                                                               */
/* 返 回 值: static void                                                      */
/* 操作流程:                                                                  */
/* 其它说明: 无                                                               */
/* 修改记录:                                                                  */
/* -------------------------------------------------------------------------- */
/*     2020-11-20              v 1.0.0       Leonard       创建函数           */
/*<FUNC->**********************************************************************/
static void yModem_Flush(void)
{
    int  xRet;
    char ch;

    while (1)
    {
        xRet = yModem_GetChar(&ch);

        if (0 == xRet)
        {
            break;
        }
    }

    return;
}

/*<FUNC+>**********************************************************************/
/* 函数名称: yModem_ReceivePacket                                             */
/* 功能描述: 接收数据包, 可能是一个块数据, 也可能是通信信号数据             */
/* 输入参数: ps --- 指向传输流信息的结构指针                                 */
/* 输出参数: 无                                                               */
/* 返 回 值: YMODEM_OK      - 接收成功                                        */
/*           YMODEM_TIMEOUT - 接收超时                                        */
/*           YMODEM_EOT     - 传输结束                                        */
/*           YMODEM_CANCEL  - 取消传输                                        */
/*           YMODEM_FRAME   - 帧序号错误                                      */
/*           YMODEM_CKSUM   - 帧校验错误                                      */
/* 操作流程:                                                                  */
/* 其它说明: 接收成功时, 接收的数据存放在传输流的缓存区中                   */
/* 修改记录:                                                                  */
/* -------------------------------------------------------------------------- */
/*     2020-11-20              v 1.0.0       Leonard       创建函数           */
/*<FUNC->**********************************************************************/
static int yModem_ReceivePacket(T_yModem_STREAM *ps)
{
    char ch;                                            /* 当前接收的字符     */
    int usChk;                                          /* CRC校验码          */
    int xRet      = YMODEM_OK;                          /* 返回值             */
    int xHdrFound = 0;                                  /* 找到帧头的标识     */
    int xHdrChars = 0;                                  /* 帧头字符计数       */
    int xTotalCAN = 0;                                  /* 接收到CAN的次数    */
    int xCnt;                                           /* 循环计数值         */
    int xRslt;                                          /* 执行结果           */

    /**************************************************************************/
    /* 允许发送ACK响应时, 则发送ACK                                          */
    /**************************************************************************/
    if (0 != ps->xIsTxACK)
    {
        yModem_PutChar(ASCII_ACK);
        ps->xIsTxACK = 0;
    }

    /**************************************************************************/
    /* 循环读取字符;遇到通信信号(EOT/CAN)或读取超时,函数退出;               */
    /* 否则直到接收到数据块起始字符(SOH/STX)才会退出循环.                   */
    /**************************************************************************/
    while (0 == xHdrFound)
    {
        xRslt = yModem_GetChar(&ch);

        /**********************************************************************/
        /* 读取超时, 等待传输线空闲后函数返回超时错误                        */
        /**********************************************************************/
        if (0 == xRslt)
        {
            yModem_Flush();
            xRet = YMODEM_TIMEOUT;
            goto EXIT_LABEL;
        }

        xHdrChars++;

        switch (ch)
        {
        /**********************************************************************/
        /* 起始块: SOH 00    FF     filename[] filezise[] NUL[] CRCH CRCL     */
        /* 结束块: SOH 00    FF     NUL[128, 以0填充]           CRCH CRCL     */
        /* 数据块: SOH [num] [~num] data[1..128]       1A...1A  CRCH CRCL     */
        /**********************************************************************/
        case ASCII_SOH:
            ps->xTotalSOH++;
            xHdrFound = 1;
            break;

        /**********************************************************************/
        /* 数据块: STX [num] [~num] data[1024]                CRCH CRCL       */
        /*         STX [num] [~num] data[128..1024]  1A...1A  CRCH CRCL       */
        /**********************************************************************/
        case ASCII_STX:
            ps->xTotalSTX++;
            xHdrFound = 1;
            break;

        /**********************************************************************/
        /* 通信信号: 首次接收EOT, 认为是结束传输, 函数返回                   */
        /**********************************************************************/
        case ASCII_EOT:
            if (1 == xHdrChars)
            {
                xRet = YMODEM_EOT;
                goto EXIT_LABEL;
            }

            break;

        /**********************************************************************/
        /* 通信信号: 连续收到2个CAN会认为终止传输, 函数返回                  */
        /**********************************************************************/
        case ASCII_CAN:
            ps->xTotalCAN++;

            if (++xTotalCAN > YMODEM_CAN_COUNT)
            {
                xRet = YMODEM_CANCEL;
                goto EXIT_LABEL;
            }

            break;

        default:
            break;
        }
    }

    /**************************************************************************/
    /* 接收块编号, 超时则函数返回                                            */
    /**************************************************************************/
    xRslt = yModem_GetChar((char *)(&ps->ucBlk));

    if (0 == xRslt)
    {
        xRet = YMODEM_TIMEOUT;
        goto EXIT_LABEL;
    }

    /**************************************************************************/
    /* 接收块编号的反码, 超时则函数返回                                      */
    /**************************************************************************/
    xRslt = yModem_GetChar((char *)(&ps->ucCBlk));

    if (0 == xRslt)
    {
        xRet = YMODEM_TIMEOUT;
        goto EXIT_LABEL;
    }

    /**************************************************************************/
    /* 依据数据包长度接收块数据, 接收超时则函数返回                          */
    /**************************************************************************/
    ps->xPktLen = (ch == ASCII_SOH) ? PACKET_SIZE_128 : PACKET_SIZE_1024;
    ps->pPkt    = &ps->cPkt[0];

    for (xCnt = 0; xCnt < ps->xPktLen; xCnt++)
    {
        xRslt = yModem_GetChar(&ch);

        if (0 != xRslt)
        {
            ps->cPkt[xCnt] = ch;
        }
        else
        {
            xRet = YMODEM_TIMEOUT;
            goto EXIT_LABEL;
        }
    }

    /**************************************************************************/
    /* 获取校验字节                                                           */
    /**************************************************************************/
    xRslt = yModem_GetChar((char *)(&ps->ucCRC1));

    if (0 == xRslt)
    {
        xRet = YMODEM_TIMEOUT;
        goto EXIT_LABEL;
    }

    if (0 != ps->xCRCMode)
    {
        xRslt = yModem_GetChar((char *)(&ps->ucCRC2));

        if (0 == xRslt)
        {
            xRet = YMODEM_TIMEOUT;
            goto EXIT_LABEL;
        }
    }

    /**************************************************************************/
    /* 检查数据帧的编号                                                       */
    /**************************************************************************/
    if ((ps->ucBlk ^ ps->ucCBlk) != (unsigned char)0xFF)
    {
        xRet = YMODEM_FRAME;
        goto EXIT_LABEL;
    }

    /**************************************************************************/
    /* 数据包校验                                                             */
    /**************************************************************************/
    if (0 != ps->xCRCMode)
    {
        usChk = CRC16_1021((unsigned char *)(&ps->cPkt[0]), ps->xPktLen);

        if (usChk != ((ps->ucCRC1 << 8) | ps->ucCRC2))
        {
            xRet = YMODEM_CKSUM;
            goto EXIT_LABEL;
        }
    }
    else
    {
        for (usChk = 0, xCnt = 0; xCnt < ps->xPktLen; xCnt++)
        {
            usChk += ps->cPkt[xCnt];
        }

        if (ps->ucCRC1 != (usChk & 0xFF))
        {
            xRet = YMODEM_CKSUM;
            goto EXIT_LABEL;
        }
    }

EXIT_LABEL:
    return xRet;
}

/*<FUNC+>**********************************************************************/
/* 函数名称: yModem_SendPacket                                                */
/* 功能描述: 发送数据块                                                       */
/* 输入参数: pData --- 要发送的数据                                           */
/*           xDataSize --- 要发送的数据大小                                   */
/*           xBlkNo --- 数据块编号                                            */
/* 输出参数: 无                                                               */
/* 返 回 值: static void                                                      */
/* 操作流程:                                                                  */
/* 其它说明: 无                                                               */
/* 修改记录:                                                                  */
/* -------------------------------------------------------------------------- */
/*     2020-11-20              v 1.0.0       Leonard       创建函数           */
/*<FUNC->**********************************************************************/
static void yModem_SendPacket(unsigned char *pData, int xDataSize, int xBlkNo)
{
    int  xCnt;
    int  xPktSize;
    int  usCRC;
    char Start;

    /**************************************************************************/
    /* 第0块数据采用128字节的短包, 其他采用1K/128的数据包                    */
    /**************************************************************************/
    if (0 == xBlkNo)
    {
        Start = ASCII_SOH;
        xPktSize = PACKET_SIZE_128;
    }
    else
    {
        if (xDataSize > PACKET_SIZE_128)
        {
            Start = ASCII_STX;
            xPktSize = PACKET_SIZE_1024;
        }
        else
        {
            Start = ASCII_SOH;
            xPktSize = PACKET_SIZE_128;
        }
    }

    /**************************************************************************/
    /* 发送数据块头                                                           */
    /**************************************************************************/
    yModem_PutChar(Start & 0xFF);
    yModem_PutChar(xBlkNo & 0xFF);
    yModem_PutChar(~xBlkNo & 0xFF);

    /**************************************************************************/
    /* 发送数据                                                               */
    /**************************************************************************/
    for (xCnt = 0; xCnt < xPktSize; xCnt++)
    {
        if (xCnt < xDataSize)
        {
            yModem_PutChar(pData[xCnt]);
        }
        else
        {
            yModem_PutChar(ASCII_SUB);
        }
    }

    /**************************************************************************/
    /* 发送CRC                                                                */
    /**************************************************************************/
    usCRC = CRC16_1021(pData, xPktSize);
    yModem_PutChar((usCRC >> 8) & 0xFF);
    yModem_PutChar(usCRC & 0xFF);

    return;
}

/*<FUNC+>**********************************************************************/
/* 函数名称: yModem_SendPacket0                                               */
/* 功能描述: 发送数据块0                                                      */
/* 输入参数: sFileName --- 文件名称                                           */
/*           ulSize --- 文件大小, 以字节为单位(10进制表示)                   */
/* 输出参数: 无                                                               */
/* 返 回 值: static void                                                      */
/* 操作流程:                                                                  */
/* 其它说明: 文件名字符串长度 <= 116B                                        */
/* 修改记录:                                                                  */
/* -------------------------------------------------------------------------- */
/*     2020-11-20              v 1.0.0       Leonard       创建函数           */
/*<FUNC->**********************************************************************/
static void yModem_SendPacket0(char *sFileName, int ulSize)
{
    const char *pFileLen;  
    unsigned long count = 0;
    unsigned char block[PACKET_SIZE_128];

    if (sFileName)
    {
        while (*sFileName && (count < FILE_NAME_LENGTH))
        {
            block[count++] = *sFileName++;
        }

        block[count++] = 0;

        pFileLen = Fn_ValToStr_Simple(ulSize);
        while (*pFileLen)
        {
            block[count++] = *pFileLen++;
        }
    }

    while (count < PACKET_SIZE_128)
    {
        block[count++] = ASCII_NUL;
    }

    yModem_SendPacket(block, PACKET_SIZE_128, 0);

    return;
}

/*<FUNC+>**********************************************************************/
/* 函数名称: yModem_SendDataPackets                                           */
/* 功能描述: 发送数据包                                                       */
/* 输入参数: pData --- 指向数据的指针                                         */
/*           ulSize --- 数据长度                                              */
/* 输出参数: 无                                                               */
/* 返 回 值: static void                                                      */
/* 操作流程:                                                                  */
/* 其它说明: 无                                                               */
/* 修改记录:                                                                  */
/* -------------------------------------------------------------------------- */
/*     2020-11-20              v 1.0.0       Leonard       创建函数           */
/*<FUNC->**********************************************************************/
static void yModem_SendDataPackets(unsigned char *pData, int ulSize)
{
    int xBlkNo = 1;
    int ulSendSize;
    char ch;
    int xRslt;

    while (ulSize > 0)
    {
        if (ulSize > PACKET_SIZE_1024)
        {
            ulSendSize = PACKET_SIZE_1024;
        }
        else
        {
            ulSendSize = ulSize;
        }

        yModem_SendPacket(pData, ulSendSize, xBlkNo);

        xRslt = yModem_GetChar(&ch);

        if (0 == xRslt)
        {
            goto EXIT_LABEL;
        }

        if (ASCII_ACK == ch)
        {
            xBlkNo++;
            pData += ulSendSize;
            ulSize -= ulSendSize;
        }

        if (ASCII_CAN == ch)
        {
            goto EXIT_LABEL;
        }
    }

EXIT_LABEL:
    return;
}

/******************************************************************************/
/*                                全局函数实现                                */
/******************************************************************************/
/*<FUNC+>**********************************************************************/
/* 函数名称: yModem_ReceiveOpen                                               */
/* 功能描述: 打开YMODEM接收器                                                 */
/* 输入参数: ps --- 指向传输控制流的指针                                     */
/* 输出参数: 无                                                               */
/* 返 回 值: int  <0 开启失败                                                 */
/* 操作流程:                                                                  */
/* 其它说明: 无                                                               */
/* 修改记录:                                                                  */
/* -------------------------------------------------------------------------- */
/*     2020-11-20              v 1.0.0       Leonard       创建函数           */
/*<FUNC->**********************************************************************/
int yModem_ReceiveOpen(T_yModem_STREAM *ps)
{
    int xRetries    = YMODEM_MAX_RETRIES;
    int xCRCRetries = YMODEM_MAX_RETRIES_WITH_CRC;
    int xCnt        = 0;
    int xRslt       = 0;

    /**************************************************************************/
    /* 初始化传输流的数据                                                    */
    /**************************************************************************/
    ps->xPktLen  = 0;
    ps->xCRCMode = 1;
    ps->xIsTxACK = 0;
    ps->xIsEOT   = 0;

    ps->xTotalSOH = 0;
    ps->xTotalSTX = 0;
    ps->xTotalCAN = 0;
    ps->xTotalRetries = 0;

    /**************************************************************************/
    /* 接收端发送字符'C', 启动传输                                           */
    /**************************************************************************/
    yModem_PutChar('C');

    /**************************************************************************/
    /* 在有限的重试次数下, 与接收端握手, 并接收文件名数据块                 */
    /**************************************************************************/
    while (xRetries-- > 0)
    {
        xRslt = yModem_ReceivePacket(ps);

        /**********************************************************************/
        /* 处理收到的数据块                                                  */
        /**********************************************************************/
        if (YMODEM_OK == xRslt)
        {
            /******************************************************************/
            /* 收到数据块0, 即文件名数据块                                   */
            /******************************************************************/
            if (0 == ps->ucBlk)
            {
                /**************************************************************/
                /* 获取文件名称,格式如下: xxx_v100.bin -> v1.0.0版本         */
                /**************************************************************/
                memset(ps->sFileName, 0, sizeof(ps->sFileName));

                while (*ps->pPkt)
                {
                    if (xCnt < (sizeof(ps->sFileName) - 1))
                    {
                        ps->sFileName[xCnt++] = *ps->pPkt;
                    }

                    ps->pPkt++;
                }

                /**************************************************************/
                /* 获取文件长度                                              */
                /**************************************************************/
                ps->pPkt++;
                ps->xFileLength = Fn_atoi((const char **)&(ps->pPkt));
                
                /**************************************************************/
                /* 先回复ACK再发送'C'请求发送正文                            */
                /**************************************************************/
                yModem_PutChar(ASCII_ACK);
                yModem_PutChar('C');

                /**************************************************************/
                /* 准备读取数据,并记录已读取长度(起始包后必为第1包数据)     */
                /**************************************************************/
                ps->xReadLength = 0;
                ps->ucNextBlk = 1;
                ps->xPktLen = 0;
            }
            else
            {
                xRslt = YMODEM_SEQUENCE;
            }

            break;
        }
        /**********************************************************************/
        /* 超时: 以CRC模式重试; 重试次数到达后, 以校验和模式重试            */
        /**********************************************************************/
        else if (YMODEM_TIMEOUT == xRslt)
        {
            if (--xCRCRetries <= 0)
            {
                ps->xCRCMode = 0;
            }

            yModem_PutChar((ps->xCRCMode) ? 'C' : ASCII_NAK);
            ps->xTotalRetries++;
        }
        /**********************************************************************/
        /* 取消: 跳出循环, 退出                                               */
        /**********************************************************************/
        else if (YMODEM_CANCEL == xRslt)
        {
            break;
        }
        /**********************************************************************/
        /* 其他: 传输结束、块编号错误、CRC错误, 仅重试数据包的接收          */
        /**********************************************************************/
        else
        {
            ;
        }
    }

    return xRslt;
}

/*<FUNC+>**********************************************************************/
/* 函数名称: yModem_ReceiveRead                                               */
/* 功能描述: 接收文件数据                                                    */
/* 输入参数: ps --- 指向传输流的指针                                         */
/*           pRdBuf --- 接收缓存区                                            */
/*           xBufSize --- 接收缓存区的大小, 以字节为单位                     */
/* 输出参数: 无                                                               */
/* 返 回 值: 接收数据的大小; 小于0时表示接收结束或出错的原因                */
/* 操作流程:                                                                  */
/* 其它说明: 无                                                               */
/* 修改记录:                                                                  */
/* -------------------------------------------------------------------------- */
/*     2020-11-20              v 1.0.0       Leonard       创建函数           */
/*<FUNC->**********************************************************************/
int yModem_ReceiveRead(T_yModem_STREAM *ps, unsigned char *pRdBuf, int xBufSize)
{
    int xRdLen = 0;
    int xRetries;
    int xRslt = YMODEM_CANCEL;

    /**************************************************************************/
    /* 尝试填充满整个缓存区的数据, 直到文件传输结束                         */
    /**************************************************************************/
    while ((0 == ps->xIsEOT) && (xRdLen < xBufSize))
    {
        /**********************************************************************/
        /* 传输流缓存区中没有数据, 需要读取块数据                            */
        /**********************************************************************/
        if (ps->xPktLen == 0)
        {
            xRetries = YMODEM_MAX_RETRIES_WITH_CRC;

            while (xRetries-- > 0)
            {
                xRslt = yModem_ReceivePacket(ps);

                /**************************************************************/
                /* 接收到块数据                                               */
                /**************************************************************/
                if (YMODEM_OK == xRslt)
                {
                    /**********************************************************/
                    /* 预期数据,回复ACK                                       */
                    /**********************************************************/
                    if (ps->ucBlk == ps->ucNextBlk)
                    {
                        /******************************************************/
                        /* 记录已读取长度,并去除结尾数据块中的填充数据      */
                        /******************************************************/
                        ps->xReadLength += ps->xPktLen;

                        if (ps->xReadLength > ps->xFileLength)
                        {
                            ps->xPktLen -= (ps->xReadLength - ps->xFileLength);
                        }

                        /*****************************************************/
                        /* 将传输流中缓存的数据拷贝出来                     */
                        /*****************************************************/
                        memcpy(pRdBuf, ps->pPkt, ps->xPktLen);

                        pRdBuf += ps->xPktLen;
                        xRdLen += ps->xPktLen;

                        break;
                    }
                    /**********************************************************/
                    /* 重传数据                                               */
                    /**********************************************************/
                    else if (ps->ucBlk == (ps->ucNextBlk - 1))
                    {
                        yModem_PutChar(ASCII_ACK);
                        continue;
                    }
                    else
                    {
                        xRslt = YMODEM_SEQUENCE;
                    }
                }

                /**************************************************************/
                /* 取消操作的处理                                             */
                /**************************************************************/
                if (xRslt == YMODEM_CANCEL)
                {
                    break;
                }

                /**************************************************************/
                /* 传输结束的处理: 先发ACK响应,再发'C'请求结束快             */
                /**************************************************************/
                if (xRslt == YMODEM_EOT)
                {
                    yModem_PutChar(ASCII_ACK);
                    yModem_PutChar((ps->xCRCMode ? 'C' : ASCII_NAK));

                    xRslt = yModem_ReceivePacket(ps);          /* 接收结束块  */

                    if (YMODEM_EOT == xRslt)
                    {
                        yModem_PutChar(ASCII_ACK);             /* ACK响应     */
                    }
                    else
                    {
                        yModem_PutChar(ASCII_CAN);
                        yModem_PutChar(ASCII_CAN);
                    }

                    ps->xIsEOT = 1;                          /* 文件传输结束 */

                    break;
                }

                /**************************************************************/
                /* 其他: 传输结束、块编号错误、CRC错误, 仅重试数据包的接收  */
                /**************************************************************/
                yModem_PutChar((ps->xCRCMode ? 'C' : ASCII_NAK));
                ps->xTotalRetries++;
            }

            /******************************************************************/
            /* 数据接收结束, 或是出错, 返回                                  */
            /******************************************************************/
            if (xRslt < 0)
            {
                xRdLen = xRslt;
                break;
            }
            else
            {
                /**************************************************************/
                /* 准备接收下一帧数据块                                      */
                /**************************************************************/
                ps->xPktLen = 0;
                ps->xIsTxACK = 1;
                ps->ucNextBlk += 1;

                /**************************************************************/
                /* 尾包的处理需要退出一次, 再进来接收EOT包                   */
                /**************************************************************/
                if (ps->xReadLength > ps->xFileLength)
                {
                    break;
                }
            }
        }
    }

    return xRdLen;
}

/*<FUNC+>**********************************************************************/
/* 函数名称: yModem_Terminate                                                 */
/* 功能描述: 传输终止                                                         */
/* 输入参数: ps --- 指向传输流的指针                                          */
/*           xIsAbort --- 是否为取消传输操作                                  */
/* 输出参数: 无                                                               */
/* 返 回 值: void                                                             */
/* 操作流程: 连发4个CAN后,再连发4个BS                                        */
/* 其它说明:                                                                  */
/* 修改记录:                                                                  */
/* -------------------------------------------------------------------------- */
/*     2020-11-20              v 1.0.0       Leonard       创建函数           */
/*<FUNC->**********************************************************************/
void yModem_Terminate(T_yModem_STREAM *ps, int xIsAbort)
{
    char ch;

    if (xIsAbort)
    {
        yModem_PutChar(ASCII_CAN);
        yModem_PutChar(ASCII_CAN);
        yModem_PutChar(ASCII_CAN);
        yModem_PutChar(ASCII_CAN);
        
        dbug(" --> yModem : %s mode, %d(SOH)/%d(STX)/%d(CAN) frames, %d retries\r\n",
                                                      ps->xCRCMode ? "CRC" : "Cksum",
                                                      ps->xTotalSOH,
                                                      ps->xTotalSTX,
                                                      ps->xTotalCAN,
                                                      ps->xTotalRetries);
        yModem_Flush();
        ps->xIsEOT = 1;
    }
    else
    {
        while (yModem_GetChar(&ch));
    }

    return;
}

/*<FUNC+>**********************************************************************/
/* 函数名称: yModem_SendFile                                                  */
/* 功能描述: 文件传输                                                         */
/* 输入参数: sFileName --- 文件名                                             */
/*           xFileSize --- 文件大小(max:256x1024B)                            */
/*           fnRd --- 读取函数指针                                            */
/*           pRdBuf --- 读取缓存区                                            */
/*           xRdBufSize --- 读出的长度                                        */
/* 输出参数: 无                                                               */
/* 返 回 值: int                                                              */
/* 操作流程:                                                                  */
/* 其它说明: 无                                                               */
/* 修改记录:                                                                  */
/* -------------------------------------------------------------------------- */
/*     2020-11-20              v 1.0.0       Leonard       创建函数           */
/*<FUNC->**********************************************************************/
int yModem_SendFile(const char *sFileName, int xFileSize, fREAD fnRd, unsigned char *pRdBuf, int xRdBufSize)
{
    char ch;                                /* 读取的字符                     */
    int  xRslt;                             /* 执行结果                       */
    int  xRdSize   = 0;                     /* 读取文件数据的长度             */
    int  xOffset   = 0;                     /* 文件偏移位置                   */
    int  xSendSize = 0;                     /* 数据块长度                     */
    int  xBlkNo    = 1;                     /* 发送块编号                     */
    int  xRet      = YMODEM_OK;             /* 返回结果                       */
    unsigned char *pData = NULL;

    /**************************************************************************/
    /* 等待发送端的请求                                                       */
    /**************************************************************************/
    while (0 == yModem_GetChar(&ch));

    if ('C' == ch)
    {
        /**********************************************************************/
        /* 发送文件名称块(块0)                                                */
        /**********************************************************************/
        yModem_SendPacket0((char *)sFileName, xFileSize);

        /**********************************************************************/
        /* 读取响应; 如果没有读取到预期的响应, 直接返回                      */
        /**********************************************************************/
        xRslt = yModem_GetChar(&ch);

        if ((0 == xRslt) || (ASCII_ACK != ch))
        {
            xRet = YMODEM_TIMEOUT;
            goto EXIT_LABEL;
        }

        /**********************************************************************/
        /* 读取数据包请求; 如果没有读取到数据包请求, 直接返回               */
        /**********************************************************************/
        xRslt = yModem_GetChar(&ch);

        if ((0 == xRslt) || ('C' != ch))
        {
            xRet = YMODEM_TIMEOUT;
            goto EXIT_LABEL;
        }

        /**********************************************************************/
        /* 循环发送文件数据                                                   */
        /**********************************************************************/
        while (xFileSize > 0)
        {
            pData   = pRdBuf;
            xRdSize = (*fnRd)(pData, xRdBufSize, xOffset);

            xFileSize -= xRdSize;
            xOffset   += xRdSize;

            while (xRdSize > 0)
            {
                /**************************************************************/
                /* 发送一个数据块                                             */
                /**************************************************************/
                if (xRdSize >= PACKET_SIZE_1024)
                {
                    xSendSize = PACKET_SIZE_1024;
                }
                else
                {
                    xSendSize = xRdSize;
                }

                yModem_SendPacket(pData, xSendSize, xBlkNo);

                /**************************************************************/
                /* 读取接收端响应                                             */
                /**************************************************************/
                xRslt = yModem_GetChar(&ch);

                if (0 == xRslt)
                {
                    xRet = YMODEM_TIMEOUT;
                    goto EXIT_LABEL;
                }

                if (ASCII_ACK == ch)
                {
                    xBlkNo++;
                    pData += xSendSize;
                    xRdSize -= xSendSize;
                }
                else
                {
                    xRet = YMODEM_TIMEOUT;
                    goto EXIT_LABEL;
                }
            }
        }

        /**********************************************************************/
        /* 发送文件传输结束信号, 并等待响应                                  */
        /**********************************************************************/
        yModem_msDelay(5 * 1000);

        while (1)
        {
            yModem_PutChar(ASCII_EOT);

            xRslt = yModem_GetChar(&ch);

            if ((0 != xRslt) && (ASCII_ACK == ch))
            {
                break;
            }
        }

        /**********************************************************************/
        /* 发送文件接收块                                                     */
        /**********************************************************************/
        xRslt = yModem_GetChar(&ch);

        if (0 == xRslt)
        {
            xRet = YMODEM_TIMEOUT;
            goto EXIT_LABEL;
        }

        if ('C' == ch)
        {
            yModem_SendPacket0(NULL, 0);
            yModem_GetChar(&ch);
        }
    }

EXIT_LABEL:

    if (xRet != YMODEM_OK)
    {
        yModem_PutChar(ASCII_CAN);
        yModem_PutChar(ASCII_CAN);
    }

    return xRet;
}

